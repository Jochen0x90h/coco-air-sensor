#include "bme68x.h"
#include <iostream>
#include <iomanip>


/*
    Test the original Bosch BME68x C API by simulating SPI read/write operations.
*/

#define dec(x) std::dec << std::setw(0) << int(x)
#define hex(x) std::hex << std::setw(2) << std::setfill('0') << int(x)

bool bank = false;
uint8_t bank0[128] = {
    0x8c, 0x6f, 0x89, 0x3e, 0x1a, 0x3c, 0x2e, 0x06, 0xb0, 0xc0, 0xea, 0x66, 0x03, 0x00, 0x35, 0x91,
    0x71, 0xd7, 0x58, 0x00, 0xaf, 0x16, 0xf0, 0xff, 0x37, 0x1e, 0x00, 0x00, 0x8e, 0xef, 0x5c, 0xf8,
    0x1e, 0x9a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0xc0,
    0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x00, 0x01, 0x00, 0xc2, 0x1f, 0x60, 0x03, 0x00,
    0x00, 0x87, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x61, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x40, 0x00,
    0x00, 0x3f, 0x4e, 0x2f, 0x00, 0x2d, 0x14, 0x78, 0x9c, 0x56, 0x66, 0x19, 0xf3, 0xe8, 0x12, 0xc2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x80
};
uint8_t bank1[128] = {
    0x29, 0xaa, 0x16, 0xcb, 0x13, 0x06, 0x48, 0x21, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x04, 0x02, 0xa0,
    0x10, 0x00, 0x40, 0x00, 0x80, 0x00, 0x20, 0x00, 0x1f, 0x7f, 0x1f, 0x10, 0x00, 0x80, 0x00, 0x57,
    0xe1, 0x80, 0x7a, 0xda, 0x00, 0x41, 0x54, 0x80, 0x00, 0x00, 0xd8, 0x65, 0x00, 0x04, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00,
    0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04,
    0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x02, 0x10, 0x48, 0x0c, 0x00, 0x00, 0x0f, 0x04, 0xfe, 0x16, 0x9b, 0x08, 0x10, 0x00
};



BME68X_INTF_RET_TYPE bme68x_spi_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr) {
    reg_addr &= 0x7f;
    std::cout << "read " << hex(reg_addr + (bank ? 0 : 0x80)) << " (" << dec(len) << ") ";
    uint8_t *data = bank ? bank1 : bank0;
    for (uint32_t i = 0; i < len; i++) {
        reg_data[i] = data[reg_addr + i];
        std::cout << hex(reg_data[i]) << ' ';
    }
    std::cout << std::endl;
    return 0;
}

BME68X_INTF_RET_TYPE bme68x_spi_write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, void *intf_ptr) {
    reg_addr &= 0x7f;
    std::cout << "write " << hex(reg_addr + (bank ? 0 : 0x80)) << " (" << dec(len) << ") ";

    if (reg_addr == 0x73) {
        bank = (reg_data[0] & BME68X_MEM_PAGE_MSK) != 0;
    }

    uint8_t *data = bank ? bank1 : bank0;
    for (uint32_t i = 0; i < len; i++) {
        data[reg_addr + i] = reg_data[i];
        std::cout << hex(reg_data[i]) << ' ';
    }
    std::cout << std::endl;
    return 0;
}

void bme68x_delay_us(uint32_t period, void *intf_ptr) {
    std::cout << "delay " << dec(period) << "us" << std::endl;
}


int main() {
    struct bme68x_dev bme;
    int8_t rslt;


    // initialize BME68x device structure for SPI interface
    bme.intf = BME68X_SPI_INTF;
    bme.read = bme68x_spi_read;
    bme.write = bme68x_spi_write;
    bme.delay_us = bme68x_delay_us;
    bme.amb_temp = 25; /* The ambient temperature in deg C is used for defining the heater temperature */

    std::cout << "* bme68x_init" << std::endl;
    rslt = bme68x_init(&bme);

    std::cout << "* bme68x_set_conf" << std::endl;
    bme68x_conf conf;
    conf.filter = BME68X_FILTER_OFF;
    conf.odr = BME68X_ODR_NONE;
    conf.os_hum = BME68X_OS_16X;
    conf.os_pres = BME68X_OS_1X;
    conf.os_temp = BME68X_OS_2X;
    rslt = bme68x_set_conf(&conf, &bme);

    std::cout << "* bme68x_set_heatr_conf" << std::endl;
    bme68x_heatr_conf heatr_conf;
    heatr_conf.enable = BME68X_ENABLE;
    heatr_conf.heatr_temp = 300;
    heatr_conf.heatr_dur = 100;
    rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &bme);

    std::cout << "* bme68x_set_op_mode" << std::endl;
    rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme);


    /* Calculate delay period in microseconds */
    std::cout << "* bme68x_get_meas_dur" << std::endl;
    uint32_t del_period = bme68x_get_meas_dur(BME68X_FORCED_MODE, &conf, &bme) + (heatr_conf.heatr_dur * 1000);
    bme.delay_us(del_period, bme.intf_ptr);

    std::cout << "* bme68x_get_data" << std::endl;
    bme68x_data data;
    uint8_t n_fields;
    rslt = bme68x_get_data(BME68X_FORCED_MODE, &data, &n_fields, &bme);

    // print values
    std::cout << data.temperature << "°C" << std::endl;
    std::cout << data.humidity << "%" << std::endl;
    std::cout << data.pressure * 0.01f << "hPa" << std::endl;
    std::cout << data.gas_resistance << "Ω" << std::endl;

    return 0;
}
